<!DOCTYPE html>
<html>
    <head>
        <!-- basic style -->
        <link rel="stylesheet" href="../../style/basic.css">
        <!-- highlight.js -->
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script>
        <!-- title -->
        <title>배열 | 배열 메서드</title>
    </head>
    <body>
        <!-- header -->
        <header class="header">
            <nav class="navigation">
                <a href="./07.html">이전</a>
                <a href="">홈</a>
                <a href="./09.html">다음</a>
            </nav>
        </header>

        <!-- content -->
        <div class="page_content">
            <h2>27.8 배열 메서드</h2>

            <div class="article">
                <p>
                    자바스크립트는 배열을 다룰 때 유용한 다양한 빌트인 메서드를 제공한다. Array 생성자 함수는 정적 메서드를 제공하며, 배열 객체의 프로토타입인 Array.prototype은 프로토타입 메서드를 제공한다. 배열은 사용 빈도가 높은 자료구조이므로 배열 메서드의 사용법을 잘 알아둘 필요가 있다.
                </p>
                <p>
                    배열 메서드는 결과물을 반환하는 패턴이 두 가지이므로 주의가 필요하다. 배열에는 원본 배열을 직접 변경하는 메서드와 원본 배열을 직접 변경하지 않고 새로운 배열을 생성하여 반환하는 메서드가 있다. 예를 들어 다음 예제를 살펴보자.
                </p>
                <pre>
                    <code class="javascript">
                        const arr = [1];

                        // push 메서드는 원본 배열(arr)을 직접 변경한다.
                        arr.push(2);
                        console.log(arr); // [1, 2]

                        // concat 메서드는 원본 배열(arr)을 직접 변경하지 않고 샤로운 배열을 생성하여 반환한다.
                        const result = arr.concat(3);
                        console.log(arr); // [1, 2]
                        console.log(result); // [1, 2, 3]
                    </code>
                </pre>
                <p>
                    ES5부터 도입된 배열 메서드는 대부분 원본 배열을 직접 변경하지 않지만 초창기 배열 메서드는 원본 배열을 직접 변경하는 경우가 많다. 원본 배열을 직접 변경하는 메서드는 외부 상태를 직접 변경하는 부수 효과가 있으므로 사용할 때 주의해야 한다. 따라서 가급적 원본 배열을 직접 변경하지 않는 메서드를 사용하는 편이 좋다.
                </p>
                <p>
                    배열이 제공하는 메서드 중에서 사용 빈도가 높은 메서드에 대해 살펴보도록 하자.
                </p>
                <div class="sub_article">
                    <p>
                        Array.isArray는 Array 생성자 함수의 정적 메서드다. 27.4절 "배열 생성"에서 살펴본 Array.of와 Array.from도 Array 생성자 함수의 정적 메서드다.
                    </p>
                    <p>
                        Array.isArray 메서드는 전달된 인수가 배열이면 true, 배열이 아니면 false를 반환한다.
                    </p>
                    <pre>
                        <code class="javascript">
                            // true
                            Array.isArray([]);
                            Array.isArray([1, 2]);
                            Array.isArray(new Array());

                            // false
                            Array.isArray();
                            Array.isArray({});
                            Array.isArray(null);
                            Array.isArray(undefined);
                            Array.isArray(1);
                            Array.isArray('Array');
                            Array.isArray(true);
                            Array.isArray(false);
                            Array.isArray({ 0: 1, length: 1 });
                        </code>
                    </pre>
                </div>
                <div class="sub_article">
                    <p>
                        indexOf 메서드는 원본 배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환한다.
                    </p>
                    <p>
                        원본 배열에 인수로 전달한 요소와 중복되는 요소가 여러 개 있다면 첫 번째로 검색된 요소의 인덱스를 반환한다.
                    </p>
                    <p>
                        원본 배열에 인수로 전달한 요소가 존재하지 않으면 -1을 반환한다.
                    </p>
                    <pre>
                        <code class="javascript">
                            const arr = [1, 2, 2, 3];

                            // 배열 arr에서 요소 2를 검색하여 첫 번째로 검색된 요소의 인덱스를 반환한다.
                            arr.indexOf(2); // 1

                            // 배열 arr에 요소 4가 없으므로 -1을 반환한다.
                            arr.indexOf(4); // -1

                            // 두 번째 인수는 검색을 시작할 인덱스다. 두 번째 인수를 생략하면 처음부터 검색한다.
                            arr.indexOf(2, 2); // 2
                        </code>
                    </pre>
                    <p>
                        indexOf 메서드는 배열에 특정 요소가 존재하는지 확인할 때 유용하다.
                    </p>
                    <pre>
                        <code class="javascript">
                            const foods = ['apple', 'banana', 'orange'];

                            // foods 배열에 'orange' 요소가 존재하는지 확인한다.
                            if (foods.indexOf('orange') === -1) {
                                // foods 배열에 'orange' 요소가 존재하지 않으면 'orange' 요소를 추가한다.
                                foods.push('orange');
                            }

                            console.log(foods); // ['apple', 'banana', 'orange']
                        </code>
                    </pre>
                    <p>
                        indexOf 메서드 대신 ES7에서 도입된 Array.prototype.includes 메서드를 사용하면 가독성이 더 좋다.
                    </p>
                    <pre>
                        <code class="javascript">
                            const foods = ['apple', 'banana', 'orange'];

                            // foods 배열에 'orange' 요소가 존재하는지 확인한다.
                            if (!foods.includes('orange')) {
                                // foods 배열에 'orange' 요소가 존재하지 않으면 'orange' 요소를 추가한다.
                                foods.push('orange');
                            }

                            console.log(foods); // ['apple', 'banana', 'orange']
                        </code>
                    </pre>
                </div>
                <div class="sub_article">
                    <p>
                        push 메서드는 인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고 변경된 length 프로퍼티 값을 반환한다. push 메서드는 원본 배열을 직접 변경한다.
                    </p>
                    <pre>
                        <code class="javascript">
                            const arr = [1, 2];

                            // 인수로 전달받은 모든 값을 원본 배열 arr의 마지막 요소로 추가하고 변경된 length 값을 반환한다.
                            let result = arr.push(3, 4);
                            console.log(result); // 4

                            // push 메서드는 원본 배열을 직접 변경한다.
                            console.log(arr); // [1, 2, 3, 4]
                        </code>
                    </pre>
                    <p>
                        push 메서드는 성능 면에서 좋지 않다. 마지막 요소로 추가할 요소가 하나뿐이라면 push 메서드를 사용하지 않고 length 프로퍼티를 사용하여 배열의 마지막에 요소를 직접 추가할 수도 있다. 이 방법이 push 메서드보다 빠르다.
                    </p>
                    <pre>
                        <code class="javascript">
                            const arr = [1, 2];

                            // arr.push(3)과 동일한 처리를 한다. 이 방법이 push 메서드보다 빠르다.
                            arr[arr.length] = 3;
                            console.log(arr); // [1, 2, 3]
                        </code>
                    </pre>
                    <p>
                        push 메서드는 원본 배열을 직접 변경하는 부수 효과가 있다. 따라서 push 메서드보다는 ES6의 스프레드 문법을 사용하는 편이 좋다. 스프레드 문법을 사용하면 함수 호출 없이 표현식으로 마지막에 요소를 추가할 수 있으며 부수 효과도 없다. 이에 대해서는 35장 "스프레드 문법"에서 자세히 살펴볼 것이다.
                    </p>
                    <pre>
                        <code class="javascript">
                            const arr = [1, 2];

                            // ES6 스프레드 문법
                            const newArr = [...arr, 3];
                            console.log(newArr); // [1, 2, 3]
                        </code>
                    </pre>
                </div>
                <div class="sub_article">
                    <p>
                        pop 메서드는 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다. 원본 배열이 빈 배열이면 undefined를 반환한다. pop 메서드는 원본 배열을 직접 변경한다.
                    </p>
                    <pre>
                        <code class="javascript">
                            const arr = [1, 2];

                            // 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다.
                            let result = arr.pop();
                            console.log(result); // 2

                            // pop 메서드는 원본 배열을 직접 변경한다.
                            console.log(arr); // [1]
                        </code>
                    </pre>
                    <p>
                        pop 메서드와 push 메서드를 사용하면 스택을 쉽게 구현할 수 있다.
                    </p>
                    <p>
                        스택은 데이터를 마지막에 밀어 넣고, 마지막에 밀어 넣은 데이터를 먼저 꺼내는 후입 선출 방식의 자료구조다. 스택은 언제나 가장 마지막에 밀어 넣은 최신 데이터를 먼저 취득한다. 스택에 데이터를 밀어 넣는 것을 푸시라 하고 스택에서 데이터를 꺼내는 것을 팝이라고 한다.
                    </p>
                    <p>
                        스택을 생성자 함수로 구현해 보면 다음과 같다.
                    </p>
                    <pre>
                        <code class="javascript">
                            const Stack = (function() {
                                function Stack(array = []) {
                                    if (!Array.isArray(array)) {
                                        throw new TypeError(`${array} is not an array.`);
                                    }
                                    this.array = array;
                                }

                                Stack.prototype = {
                                    constructor: Stack,
                                    // 스택의 가장 마지막에 데이터를 밀어 넣는다.
                                    push(value) {
                                        return this.array.push(value);
                                    },
                                    // 스택의 가장 마지막 데이터, 즉 가장 나중에 밀어 넣은 최신 데이터를 꺼낸다.
                                    pop() {
                                        return this.array.pop();
                                    },
                                    // 스택의 복사본 배열을 반환한다.
                                    entries() {
                                        return [...this.array];
                                    }
                                };

                                return Stack;
                            }());

                            const stack = new Stack([1, 2]);
                            console.log(stack.entries()); // [1, 2]

                            stack.push(3);
                            console.log(stack.entries()); // [1, 2, 3]

                            stack.pop();
                            console.log(stack.entries()); // [1, 2]
                        </code>
                    </pre>
                    <p>
                        스택을 클래스로 구현해보면 다음과 같다.
                    </p>
                    <pre>
                        <code class="javascript">
                            class Stack {
                                #array; // private class member

                                constructor(array = []) {
                                    if (!Array.isArray(array)) {
                                        throw new TypeError(`${array} is not an array.`);
                                    }
                                    this.#array = array;
                                }

                                // 스택의 가장 마지막에 데이터를 밀어 넣는다.
                                push(value) {
                                    return this.#array.push(value);
                                }
                                // 스탹의 가장 마지막 데이터, 즉 가장 나중에 밀어 넣은 최신 데이터를 꺼낸다.
                                pop() {
                                    return this.#array.pop();
                                }
                                // 스택의 복사본 배열을 반환한다.
                                entries() {
                                    return [...this.#array];
                                }
                            }

                            const stack = new Stack([1, 2]);
                            console.log(stack.entries()); // [1, 2]

                            stack.push(3);
                            console.log(stack.entries()); // [1, 2, 3]

                            stack.pop();
                            console.log(stack.entries()); // [1, 2]
                        </code>
                    </pre>
                </div>
                <div class="sub_article">
                    <p>
                        unshift 메서드는 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 프로퍼티 값을 반환한다. unshift 메서드는 원본 배열을 직접 변경한다.
                    </p>
                    <pre>
                        <code class="javascript">
                            const arr = [1, 2];

                            // 인수로 전달받은 모든 값을 원본 배열의 선두에 요소로 추가하고 변경된 length 값을 반환한다.
                            let result = arr.unshift(3, 4);
                            console.log(result); // 3

                            // unshift 메서드는 원본 배열을 직접 변경한다.
                            console.log(arr); // [3, 1, 2]
                        </code>
                    </pre>
                    <p>
                        unshift 메서드는 원본 배열을 직접 변경하는 부수 효과가 있다. 따라서 unshift 메서드보다 ES6의 스프레드 문법을 사용하는 편이 좋다. 스프레드 문법을 사용하면 함수 호출 없이 표현식으로 선두에 요소를 추가할 수 있으며 부수 효과도 없다. 이에 대해서는 31장 "스프레드 문법"에서 자세히 살펴볼 것이다.
                    </p>
                    <pre>
                        <code class="javascript">
                            const arr = [1, 2];

                            // ES6 스프레드 문법
                            const newArr = [3, ...arr];
                            console.log(newArr); // [3, 1, 2]
                        </code>
                    </pre>
                </div>
                <div class="sub_article">
                    <p>
                        shift 메서드는 원본 배열에서 첫 번째 요소를 제거하고 제거한 요소를 반환한다. 원본 배열이 빈 배열이라면 undefined를 반환한다. shift 메서드는 원본 배열을 직접 변경한다.
                    </p>
                    <pre>
                        <code class="javascript">
                            const arr = [1, 2];

                            // 원본 배열에서 첫 번째 요소를 제거하고 제거한 요소를 반환한다.
                            let result = arr.shift();
                            console.log(result); // 1

                            // shift 메서드는 원본 배열을 직접 변경한다.
                            console.log(arr); // [2];
                        </code>
                    </pre>
                    <p>
                        shift 메서드와 push 메서드를 사용하면 큐를 쉽게 구현할 수 있다.
                    </p>
                    <p>
                        큐는 데이터를 마지막에 밀어 넣고, 처음 데이터, 즉 가장 먼저 밀어 넣은 데이터를 먼저 꺼내는 선입 선축 방식의 자료구조다. 스택은 언제나 마지막에 밀어 넣은 최신 데이터를 취득하지만 큐는 언제나 데이터를 밀어 넣은 순서대로 취득한다.
                    </p>
                    <p>
                        큐를 생성자 함수로 구현해 보면 다음과 같다.
                    </p>
                    <pre>
                        <code class="javascript">
                            const Queue = (function() {
                                function Queue(array = []) {
                                    if (!Array.isArray(array)) {
                                        throw new TypeError(`${array} is not an array`);
                                    }
                                    this.array = array;
                                }

                                Queue.prototype = {
                                    constructor: Queue,
                                    // 큐의 가장 마지막에 데이터를 밀어 넣는다.
                                    enqueue(value) {
                                        return this.array.push(value);
                                    },
                                    // 큐의 가장 처음 데이터, 즉 가장 먼저 밀어 넣은 데이터를 꺼낸다.
                                    dequeue() {
                                        return this.array.shift();
                                    },
                                    // 큐의 복사본 배열을 반환한다.
                                    entries() {
                                        return [...this.array];
                                    }
                                };

                                return Queue;
                            }());

                            const queue = new Queue([1, 2]);
                            console.log(queue.entries()); // [1, 2]

                            queue.enqueue(3);
                            console.log(queue.entries()); // [1, 2, 3]

                            queue.dequeue();
                            console.log(queue.entries()); // [2, 3]
                        </code>
                    </pre>
                    <p>
                        큐는 클래스로 구현해보면 다음과 같다.
                    </p>
                    <pre>
                        <code class="javascript">
                            class Queue {
                                #array; // private class member

                                constructor(array = []) {
                                    if (!Array.isArray(array)) {
                                        throw new TypeError(`${array} is not an array.`);
                                    }
                                    this.#array = array;
                                }

                                // 큐의 가장 마지막에 데이터를 밀어 넣는다.
                                enqueue(value) {
                                    return this.#array.push(value);
                                }

                                // 큐의 가장 처음 데이터, 즉 가장 먼저 밀어 넣은 데이터를 꺼낸다.
                                dequeue() {
                                    return this.#array.shift();
                                }

                                // 큐의 복사본 배열을 반환한다.
                                entries() {
                                    return [...this.#array];
                                }
                            }

                            const queue = new Queue([1, 2]);
                            console.log(queue.entries()); // [1, 2]

                            queue.enqueue(3);
                            console.log(queue.entries()); // [1, 2, 3]

                            queue.dequeue();
                            console.log(queue.entries()); // [2, 3]
                        </code>
                    </pre>
                </div>
                <div class="sub_article">
                    <p>
                        concat 메서드는 인수로 전달된 값들(배열 또는 원시값)을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환한다. 인수로 전달한 값이 배열인 경우 배열을 해체하여 새로운 배열의 요소로 추가한다. 원본 배열은 변경되지 않는다.
                    </p>
                    <pre>
                        <code class="javascript">
                            const arr1 = [1, 2];
                            const arr2 = [3, 4];

                            // 배열 arr2를 원본 배열 arr1의 마지막 요소로 추가한 새로운 배열을 반환한다.
                            // 인수로 전달한 값이 배열인 경우 배열을 해체하여 새로운 배열의 요소로 추가한다.
                            let result = arr1.concat(arr2);
                            console.log(result); // [1, 2, 3, 4]

                            // 숫자를 원본 배열 arr1의 마지막 요소로 추가한 새로운 배열을 반환한다.
                            result = arr1.concat(3);
                            console.log(result); // [1, 2, 3]

                            // 배열 arr2와 숫자를 원본 배열 arr1의 마지막 요소로 추가한 새로운 배열을 반환한다.
                            result = arr1.concat(arr2, 5);
                            console.log(result); // [1, 2, 3, 4, 5]

                            // 원본 배열은 변경되지 않는다.
                            console.log(arr1); // [1, 2]
                        </code>
                    </pre>
                    <p>
                        push와 unshift 메서드는 concat 메서드로 대체할 수 있다. push와 unshift 메서드는 concat 메서드와 유사하게 동작하지만 미묘한 차이가 있다.
                    </p>
                    <p>
                        push와 unshift 메서드는 원본 배열을 직접 변경하지만 concat 메서드는 원본 배열을 변경하지 않고 새로운 배열을 반환한다. 따라서 push와 unshift 메서드를 사용할 경우 원본 배열을 반드시 변수에 저장해 두어야 하며 concat 매서드를 사용할 경우 반환값을 반드시 변수에 저장해야 한다.
                    </p>
                    <pre>
                        <code class="javascript">
                            
                        </code>
                    </pre>
                </div>
            </div>
        </div>
    </body>
</html>